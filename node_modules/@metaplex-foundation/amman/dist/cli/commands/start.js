"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startHelp = exports.handleStartCommand = void 0;
const path_1 = __importDefault(require("path"));
const utils_1 = require("../../utils");
const config_1 = require("../../utils/config");
const fs_1 = require("../../utils/fs");
const validator_1 = require("../../validator");
const utils_2 = require("../utils");
const solana_logs_1 = require("../utils/solana-logs");
async function handleStartCommand(args) {
    let config, configPath;
    try {
        try {
            ;
            ({ config, configPath } = await resolveConfig(args));
        }
        catch (err) {
            (0, utils_1.logError)(`Having trouble loading amman config from ${args.config}`);
            (0, utils_1.logError)(err);
            return { needHelp: true };
        }
        if (configPath != null) {
            (0, utils_1.logInfo)('Loading config from %s', configPath);
        }
        if (config.validator == null) {
            (0, utils_1.logError)(`This config ${config} is missing a 'validator' property`);
            process.exit(1);
        }
        (0, utils_1.logInfo)(`Running validator with ${config.validator.programs.length} custom program(s) and ${config.validator.accounts.length} remote account(s) preloaded`);
        (0, utils_1.logDebug)(config.validator);
        config.snapshot = { ...config.snapshot, load: args.load };
        await (0, validator_1.initValidator)(config, args.forceClone);
        if (config.streamTransactionLogs) {
            (0, solana_logs_1.pipeSolanaLogs)((0, utils_2.cliAmmanInstance)());
        }
        return { needHelp: false };
    }
    catch (err) {
        (0, utils_1.logError)(err);
        return { needHelp: true };
    }
}
exports.handleStartCommand = handleStartCommand;
async function resolveConfig({ config }) {
    if (config == null) {
        const { config: localConfig, configPath } = await tryLoadLocalConfigRc();
        return { config: (0, config_1.completeConfig)(localConfig), configPath };
    }
    else {
        const configPath = path_1.default.resolve(config);
        return {
            config: (0, config_1.completeConfig)(require(configPath)),
            configPath,
        };
    }
}
async function tryLoadLocalConfigRc() {
    const configPath = path_1.default.join(process.cwd(), '.ammanrc.js');
    if (await (0, fs_1.canAccess)(configPath)) {
        const config = require(configPath);
        (0, utils_1.logDebug)('Found `.ammanrc.js` in current directory and using that as config');
        return { config, configPath };
    }
    else {
        (0, utils_1.logInfo)('No config provided nor `.ammanrc.js` found in current directory. Launching with default config.');
        return { config: config_1.DEFAULT_START_CONFIG, configPath: null };
    }
}
function startHelp() {
    return `
amman start [<config.js>]

A config should be aJavaScript module exporting at a minimum 'validator' with any of the below properties:

If no config is provided, a local .ammanrc.js will be used, falling back to a default config if not found.

killRunningValidators: if true will kill any solana-test-validators currently running on the system.

programs: bpf programs which should be loaded into the test validator

jsonRpcUrl: the URL at which the test validator should listen for JSON RPC requests

websocketUrl: for the RPC websocket

ledgerDir: where the solana test validator writes the ledger

resetLedger: if true the ledger is reset to genesis at startup

verifyFees: if true the validator is not considered fully started up until it charges transaction fees
`;
}
exports.startHelp = startHelp;
//# sourceMappingURL=start.js.map