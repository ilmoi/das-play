"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureDirCleaned = exports.keypairFromFile = exports.ensureDir = exports.ensureDirSync = exports.canRead = exports.canAccess = exports.canAccessSync = void 0;
const web3_js_1 = require("@solana/web3.js");
const assert_1 = require("assert");
const constants_1 = require("constants");
const fs_1 = __importDefault(require("fs"));
const _1 = require(".");
/**
 * Ensures that a file or directory is accessible to the current user.
 * @private
 */
function canAccessSync(p) {
    try {
        fs_1.default.accessSync(p);
        return true;
    }
    catch (_) {
        return false;
    }
}
exports.canAccessSync = canAccessSync;
/**
 * Ensures that a file or directory is accessible to the current user.
 * @private
 */
async function canAccess(p, flag = constants_1.R_OK) {
    try {
        await fs_1.default.promises.access(p, flag);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.canAccess = canAccess;
/**
 * Ensures that a file or directory is readable to the current user.
 * @private
 */
async function canRead(p) {
    try {
        await fs_1.default.promises.access(p, constants_1.R_OK);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.canRead = canRead;
/**
 * Ensures that a directory is accessible to the current user.
 * IF the directory doesn't exist it attempts to create it recursively.
 * @private
 */
function ensureDirSync(dir) {
    if (!canAccessSync(dir)) {
        fs_1.default.mkdirSync(dir, { recursive: true });
        return;
    }
    // dir already exists, make sure it isn't a file
    const stat = fs_1.default.statSync(dir);
    if (!stat.isDirectory()) {
        throw new Error(`'${dir}' is not a directory`);
    }
}
exports.ensureDirSync = ensureDirSync;
/**
 * Ensures that a directory is accessible to the current user.
 * IF the directory doesn't exist it attempts to create it recursively.
 * @private
 */
async function ensureDir(dir, rmrf = false) {
    if (!(await canAccess(dir))) {
        await fs_1.default.promises.mkdir(dir, { recursive: true });
        return;
    }
    // dir already exists, make sure it isn't a file
    const stat = await fs_1.default.promises.stat(dir);
    if (!stat.isDirectory()) {
        throw new Error(`'${dir}' is not a directory`);
    }
    if (rmrf) {
        await fs_1.default.promises.rm(dir, { recursive: true });
        await fs_1.default.promises.mkdir(dir, { recursive: true });
    }
}
exports.ensureDir = ensureDir;
/** @private */
async function keypairFromFile(fullPath) {
    (0, assert_1.strict)(await canAccess(fullPath), `File ${fullPath} does not exist or is not readable`);
    const keypairString = await fs_1.default.promises.readFile(fullPath, 'utf8');
    try {
        const secretKey = Uint8Array.from(JSON.parse(keypairString));
        return web3_js_1.Keypair.fromSecretKey(secretKey);
    }
    catch (err) {
        (0, _1.logError)(err);
        throw new Error(`File ${fullPath} does not contain a valid keypair`);
    }
}
exports.keypairFromFile = keypairFromFile;
/** @private */
async function ensureDirCleaned(dir) {
    if (!canRead(dir))
        return;
    return fs_1.default.promises.rm(dir, { recursive: true });
}
exports.ensureDirCleaned = ensureDirCleaned;
//# sourceMappingURL=fs.js.map