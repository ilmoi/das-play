"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processSnapshot = void 0;
const web3_js_1 = require("@solana/web3.js");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const assets_1 = require("../assets");
const utils_1 = require("../utils");
const fs_2 = require("../utils/fs");
const { logError } = (0, utils_1.scopedLog)('process-snapshot');
async function processSnapshot(snapshotConfig) {
    if (snapshotConfig.load == null) {
        return {
            snapshotArgs: [],
            persistedSnapshotAccountInfos: [],
            snapshotAccounts: [],
            keypairs: new Map(),
        };
    }
    const fullPathToSnapshotDir = path_1.default.join(snapshotConfig.snapshotFolder, snapshotConfig.load);
    // -----------------
    // Accounts
    // -----------------
    const snapshotArgs = [];
    const fullPathToAccountsDir = path_1.default.join(fullPathToSnapshotDir, assets_1.SNAPSHOT_ACCOUNTS_DIR);
    const files = (await fs_1.promises.readdir(fullPathToAccountsDir)).filter((x) => path_1.default.extname(x) === '.json');
    const persistedSnapshotAccountInfos = await Promise.all(files.map(async (x) => {
        const accountPath = path_1.default.join(fullPathToAccountsDir, x);
        const json = await fs_1.promises.readFile(accountPath, 'utf8');
        const label = path_1.default.basename(x, '.json');
        const persistedAccount = {
            ...JSON.parse(json),
            label,
            accountPath,
        };
        return persistedAccount;
    }));
    const snapshotAccounts = [];
    for (const { label, pubkey, accountPath, account, } of persistedSnapshotAccountInfos) {
        (0, utils_1.logTrace)(`Loading account labeled ${label} with pubkey ${pubkey}`);
        snapshotArgs.push('--account');
        snapshotArgs.push(pubkey);
        snapshotArgs.push(accountPath);
        snapshotAccounts.push({
            accountId: pubkey,
            label,
            executable: account.executable,
            cluster: 'local',
        });
    }
    // -----------------
    // Keypairs
    // -----------------
    const keypairsDir = path_1.default.join(fullPathToSnapshotDir, assets_1.SNAPSHOT_KEYPAIRS_DIR);
    const keypairs = (await (0, fs_2.canAccess)(keypairsDir))
        ? await loadKeypairs(keypairsDir)
        : new Map();
    (0, utils_1.logInfo)(`Loading ${persistedSnapshotAccountInfos.length} accounts and ${keypairs.size} keypairs from snapshot at ${path_1.default.relative(process.cwd(), fullPathToSnapshotDir)}`);
    return {
        snapshotArgs,
        persistedSnapshotAccountInfos,
        snapshotAccounts,
        keypairs,
    };
}
exports.processSnapshot = processSnapshot;
async function loadKeypairs(keypairsDir) {
    const promises = (await fs_1.promises.readdir(keypairsDir))
        .filter((x) => path_1.default.extname(x) === '.json')
        .map(async function (x) {
        const label = path_1.default.basename(x, '.json');
        const fullPath = path_1.default.join(keypairsDir, x);
        const src = await fs_1.promises.readFile(fullPath, 'utf8');
        try {
            const json = JSON.parse(src);
            const data = Uint8Array.from(json);
            const keypair = web3_js_1.Keypair.fromSecretKey(data);
            return [label, keypair];
        }
        catch (err) {
            logError(err);
            logError(`Failed to load keypair ${label}`);
            logError(src);
        }
    });
    const keypairsArr = (await Promise.all(promises)).filter((x) => x != null);
    return new Map(keypairsArr);
}
//# sourceMappingURL=process-snapshot.js.map