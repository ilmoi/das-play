"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFetchAccounts = exports.saveAccount = exports.getExecutableAddress = void 0;
const amman_client_1 = require("@metaplex-foundation/amman-client");
const web3_js_1 = require("@solana/web3.js");
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const utils_1 = require("../utils");
const fs_1 = require("../utils/fs");
async function getExecutableAddress(programId) {
    const programPubkey = new web3_js_1.PublicKey(programId);
    const [executableAddress] = await web3_js_1.PublicKey.findProgramAddress([programPubkey.toBytes()], new web3_js_1.PublicKey('BPFLoaderUpgradeab1e11111111111111111111111'));
    return executableAddress.toString();
}
exports.getExecutableAddress = getExecutableAddress;
async function saveAccount(accountId, endpoint, accountsFolder, executable = false) {
    const makeRemainingArgs = (id) => [
        '-u',
        endpoint,
        '-o',
        `${accountsFolder}/${id}.json`,
        '--output',
        'json',
    ];
    (0, utils_1.logInfo)(`Saving account ${accountId} from cluster ${endpoint}`);
    (0, child_process_1.spawnSync)('solana', ['account', accountId, ...makeRemainingArgs(accountId)]);
    if (executable) {
        (0, utils_1.logInfo)(`Saving executable data for ${accountId} from cluster ${endpoint}`);
        const executableId = await getExecutableAddress(accountId);
        (0, child_process_1.spawnSync)('solana', [
            'account',
            executableId,
            ...makeRemainingArgs(executableId),
        ]);
    }
}
exports.saveAccount = saveAccount;
async function handleFetchAccounts(accountsCluster, accounts, accountsFolder, force = false) {
    if (accounts.length > 0) {
        (0, fs_1.ensureDirSync)(accountsFolder);
        for (const { accountId, cluster, executable } of accounts) {
            if (accountId == null || !(0, amman_client_1.isValidPublicKeyAddress)(accountId)) {
                throw new Error(`Account ID ${accountId} in accounts array from validator config is invalid`);
            }
            if (force ||
                !(await (0, fs_1.canAccess)(path_1.default.join(accountsFolder, `${accountId}.json`)))) {
                const endpoint = cluster !== null && cluster !== void 0 ? cluster : accountsCluster;
                try {
                    await saveAccount(accountId, endpoint, accountsFolder, executable);
                }
                catch (err) {
                    (0, utils_1.logError)(`Failed to load ${accountId} from cluster ${endpoint}`);
                    throw err;
                }
            }
        }
    }
}
exports.handleFetchAccounts = handleFetchAccounts;
//# sourceMappingURL=local-accounts.js.map