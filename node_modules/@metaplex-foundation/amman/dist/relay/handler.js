"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelayHandler = void 0;
const amman_client_1 = require("@metaplex-foundation/amman-client");
const amman_client_2 = require("@metaplex-foundation/amman-client");
const web3_js_1 = require("@solana/web3.js");
const state_1 = require("../accounts/state");
const assets_1 = require("../assets");
const log_1 = require("../utils/log");
const validator_1 = require("../validator");
const types_1 = require("./types");
const { logDebug } = (0, log_1.scopedLog)('relay');
class RelayHandler {
    constructor(accountProvider, accountPersister, snapshotPersister, ammanState, _accountStates, 
    // Keyed pubkey:label
    _allKnownLabels = {}) {
        this.accountProvider = accountProvider;
        this.accountPersister = accountPersister;
        this.snapshotPersister = snapshotPersister;
        this.ammanState = ammanState;
        this._accountStates = _accountStates;
        this._allKnownLabels = _allKnownLabels;
    }
    // -----------------
    // Account States
    // -----------------
    get accountStates() {
        return this._accountStates;
    }
    set accountStates(val) {
        // ensure we don't loose any existing subscriptions
        // (namely the relay server listening to account state changes)
        val.listeners = this._accountStates.listeners;
        this._accountStates = val;
    }
    requestAccountStates(pubkey) {
        var _a, _b;
        const states = (_b = (_a = this.accountStates.get(pubkey)) === null || _a === void 0 ? void 0 : _a.relayStates) !== null && _b !== void 0 ? _b : [];
        return { result: { pubkey, states: states !== null && states !== void 0 ? states : [] } };
    }
    // -----------------
    // Address Labels
    // -----------------
    get allKnownLabels() {
        return this._allKnownLabels;
    }
    updateAddressLabels(labels) {
        for (const [key, val] of Object.entries(labels)) {
            this._allKnownLabels[key] = val;
        }
        this.accountStates.labelKeypairs(this._allKnownLabels);
        return amman_client_1.VOID_REPLY;
    }
    // -----------------
    // Amman Version
    // -----------------
    requestAmmanVersion() {
        return { result: types_1.AMMAN_VERSION };
    }
    // -----------------
    // Restart Validator
    // -----------------
    async requestRestartValidator() {
        try {
            const { persistedAccountInfos, persistedSnapshotAccountInfos, keypairs } = await (0, validator_1.restartValidator)(this.accountStates, this.ammanState, this.ammanState.config);
            const accountInfos = (0, assets_1.mapPersistedAccountInfos)([
                ...persistedAccountInfos,
                ...persistedSnapshotAccountInfos,
            ]);
            this.accountStates = state_1.AccountStates.createInstance(this.accountProvider.connection, this.accountProvider, accountInfos, keypairs);
            return { result: void 0 };
        }
        catch (err) {
            return { err };
        }
    }
    // -----------------
    // Validator Pid
    // -----------------
    requestValidatorPid() {
        const pid = this.ammanState.validator.pid;
        if (pid == null) {
            return {
                err: 'It seems like no validator is running currently, cannot get pid',
            };
        }
        return { result: pid };
    }
    // -----------------
    // Kill Amman
    // -----------------
    async requestKillAmman() {
        if (this.ammanState.relayServer != null) {
            logDebug('Stopping relay server');
            try {
                await this.ammanState.relayServer.close();
            }
            catch (err) {
                return { err: `amman relay failed to close properly\n${err.toString}` };
            }
        }
        // NOTE: if timing issues arise due to this function returning
        // before the process has finished stopping then we need to add some _wait_
        // code here that only returns once the process cannot be reached anymore
        logDebug('Killing validator');
        process.kill(this.ammanState.validator.pid, 9);
        logDebug('Scheduling amman exit in next event loop');
        setImmediate(() => {
            logDebug('Exiting amman');
            process.exit(amman_client_2.KILL_AMMAN_EXIT_CODE);
        });
        return amman_client_1.VOID_REPLY;
    }
    // -----------------
    // Save Account
    // -----------------
    async requestAccountSave(pubkey, slot) {
        try {
            let data;
            if (slot != null) {
                data = this.accountStates.accountDataForSlot(pubkey, slot);
            }
            const accountPath = await this.accountPersister.saveAccount(new web3_js_1.PublicKey(pubkey), this.accountProvider.connection, data);
            return { result: { pubkey, accountPath } };
        }
        catch (err) {
            return { err: err.toString() };
        }
    }
    // -----------------
    // Snapshot
    // -----------------
    async requestSnapshotSave(label) {
        try {
            const addresses = this.accountStates.allAccountAddresses();
            const snapshotDir = await this.snapshotPersister.snapshot(label, addresses, this.allKnownLabels, this.accountStates.allKeypairs);
            return { result: { snapshotDir } };
        }
        catch (err) {
            return { err: err.toString() };
        }
    }
    async requestLoadSnapshot(label) {
        try {
            const { persistedAccountInfos, persistedSnapshotAccountInfos, keypairs } = await (0, validator_1.restartValidatorWithSnapshot)(this.accountStates, this.ammanState, label);
            const accountInfos = (0, assets_1.mapPersistedAccountInfos)([
                ...persistedAccountInfos,
                ...persistedSnapshotAccountInfos,
            ]);
            this._accountStates = state_1.AccountStates.createInstance(this.accountProvider.connection, this.accountProvider, accountInfos, keypairs);
            return amman_client_1.VOID_REPLY;
        }
        catch (err) {
            return { err: err.toString() };
        }
    }
    // -----------------
    // Keypair
    // -----------------
    requestStoreKeypair(id, secretKey) {
        try {
            const keypair = web3_js_1.Keypair.fromSecretKey(secretKey);
            this.accountStates.storeKeypair(id, keypair);
            return amman_client_1.VOID_REPLY;
        }
        catch (err) {
            return { err: err.toString() };
        }
    }
    requestLoadKeypair(id) {
        const keypair = this.accountStates.getKeypairById(id);
        return { result: { id, keypair: keypair === null || keypair === void 0 ? void 0 : keypair.secretKey } };
    }
    // -----------------
    // Set Account
    // -----------------
    async requestSetAccount(account) {
        const addresses = this.accountStates.allAccountAddresses();
        try {
            const { persistedAccountInfos, persistedSnapshotAccountInfos, keypairs } = await (0, validator_1.restartValidatorWithAccountOverrides)(this.accountStates, this.ammanState, addresses, this.allKnownLabels, this.accountStates.allKeypairs, new Map([[account.pubkey, account]]));
            const accountInfos = (0, assets_1.mapPersistedAccountInfos)([
                ...persistedAccountInfos,
                ...persistedSnapshotAccountInfos,
            ]);
            this._accountStates = state_1.AccountStates.createInstance(this.accountProvider.connection, this.accountProvider, accountInfos, keypairs);
            return amman_client_1.VOID_REPLY;
        }
        catch (err) {
            return { err: err.toString() };
        }
    }
}
exports.RelayHandler = RelayHandler;
//# sourceMappingURL=handler.js.map