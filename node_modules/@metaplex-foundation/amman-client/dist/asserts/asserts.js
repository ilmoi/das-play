"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertErrorMatches = exports.assertContainMessages = exports.assertError = exports.assertTransactionError = exports.assertTransactionSuccess = exports.assertTransactionSummary = exports.assertConfirmedTransaction = void 0;
const consts_1 = require("../consts");
const log_1 = require("../utils/log");
/**
 * Asserts details about a confirmed transaction
 *
 * @deprecated use {@link assertTransactionSuccess} or {@link assertTransactionError} instead
 *
 * @param t
 * @param tx the confirmed transaction to verify
 * @param args specify what details should be verified
 * @category asserts
 */
function assertConfirmedTransaction(t, tx, args = {}) {
    var _a, _b;
    t.equal((_a = tx.meta) === null || _a === void 0 ? void 0 : _a.err, null, 'confirmed transaction has no error');
    if (args.fee != null) {
        t.equal((_b = tx.meta) === null || _b === void 0 ? void 0 : _b.fee, args.fee, 'confirmed transaction fee matches');
    }
}
exports.assertConfirmedTransaction = assertConfirmedTransaction;
/**
 * Asserts details about a {@link TransactionSummary}.
 *
 * @deprecated use {@link assertTransactionSuccess} or {@link assertTransactionError} instead
 *
 * @param t
 * @param summary transaction summary to verify
 * @param args specify what details should be verified
 * @category asserts
 */
function assertTransactionSummary(t, summary, args = {}) {
    var _a;
    const { failed = false } = args;
    if (failed) {
        t.ok(summary.transactionError != null, 'transaction summary has transaction error');
    }
    else {
        t.ok(summary.transactionError == null, 'transaction summary has no transaction error');
        if (summary.loggedError != null) {
            t.fail((_a = summary.loggedError.stack) !== null && _a !== void 0 ? _a : summary.loggedError.toString());
        }
    }
    if (args.fee != null) {
        t.equal(summary.fee, args.fee, 'transaction summary fee matches');
    }
    if (args.msgRxs != null) {
        assertContainMessages(t, summary.logMessages, args.msgRxs, {});
    }
}
exports.assertTransactionSummary = assertTransactionSummary;
/**
 * Asserts that a transaction completed successfully and optionally checks for
 * messages in the transaction logs.
 *
 */
function assertTransactionSuccess(t, details, msgRxs) {
    var _a, _b, _c;
    const label = (_b = (_a = details.txLabel) !== null && _a !== void 0 ? _a : details.txSignature) !== null && _b !== void 0 ? _b : 'N/A';
    const summary = details.txSummary;
    if (summary.loggedError != null) {
        const errMsg = (_c = summary.loggedError.stack) !== null && _c !== void 0 ? _c : summary.loggedError.toString();
        t.fail(`Transaction ('${label}') failed ${errMsg}`);
        (0, log_1.logError)({ logs: summary.logMessages });
        if (details.txSignature != null) {
            (0, log_1.logInfo)(`Inspect via: ${consts_1.AMMAN_EXPLORER}/#/tx/${details.txSignature}`);
        }
        return;
    }
    t.ok(summary.transactionError == null, `transaction summary of '${label}' has no transaction error`);
    if (msgRxs != null) {
        assertContainMessages(t, summary.logMessages, msgRxs, details);
    }
}
exports.assertTransactionSuccess = assertTransactionSuccess;
/**
 * Asserts that the provided {@link ConfirmedTransactionDetails} has an error
 * that matches the provided requirements.
 *
 * Provide either an `Error` to {@link errOrRx} to verify the error type or a
 * {@link RegExp} to only verify the error message.
 * In order to verify both provide an `Error` to {@link errOrRx} and the {@link
 * RegExp} via {@link msgRx}.
 *
 * @param t
 * @param details result of executing a transaction
 * @param errOrRx the type of the error to expect or the {@link msgRx} to match
 * @param msgRx a {@link RegExp} that the error message is expected to match
 */
function assertTransactionError(t, details, errOrRx, msgRx) {
    const err = typeof errOrRx === 'function' ? errOrRx : undefined;
    const rx = typeof errOrRx === 'function' ? msgRx : errOrRx;
    // Support checking for merly the existence of a transaction error
    if (err == null && rx == null) {
        t.ok(details.txSummary.transactionError != null, 'transaction failed');
    }
    else {
        assertErrorMatches(t, details.txSummary.loggedError, {
            type: err,
            msgRx: rx,
            txSignature: details.txSignature,
            logMessages: details.txSummary.logMessages,
        });
    }
}
exports.assertTransactionError = assertTransactionError;
/**
 * Asserts that the provided error contains specific information as part of the
 * error message or the attached error logs.
 *
 * To check for they error type instead use {@link assertErrorMatches} instead.
 *
 * @param t
 * @param err error to verify
 * @param msgRxs list of {@link RegExp} which will be matched on the error _message_ or `err.logs`.
 * @param opts options to customize the assertion diagnostics
 * @category asserts
 */
function assertError(t, err, msgRxs, opts = {}) {
    var _a;
    t.ok(err != null, 'error encountered');
    const errWithLogs = err;
    t.ok(errWithLogs.logs != null, 'error has logs');
    const errorMessages = err
        .toString()
        .split('\n')
        .concat((_a = errWithLogs.logs) !== null && _a !== void 0 ? _a : []);
    assertContainMessages(t, errorMessages, msgRxs, opts);
}
exports.assertError = assertError;
/**
 * Asserts that the provided logs contain specific messages.
 *
 * @param t
 * @param logs containing messages to match
 * @param msgRxs list of {@link RegExp} which will be matched on the {@link logs}.
 * @param opts options to customize the assertion diagnostics
 * @param label label of the container we check for messages to include in the error message
 * @category asserts
 * @private
 */
function assertContainMessages(t, logs, msgRxs, opts, label = 'log messages') {
    var _a, _b;
    const txLabel = (_b = (_a = opts.txLabel) !== null && _a !== void 0 ? _a : opts.txSignature) !== null && _b !== void 0 ? _b : 'N/A';
    for (const msgRx of msgRxs) {
        const hasMatch = logs.some((x) => msgRx.test(x));
        if (!hasMatch) {
            (0, log_1.logError)('Failed to find %s inside', msgRx.toString());
            (0, log_1.logError)(logs.join('\n  '));
            if (opts.txSignature != null) {
                (0, log_1.logInfo)(`Inspect via: ${consts_1.AMMAN_EXPLORER}/#/tx/${opts.txSignature}`);
            }
        }
        if (hasMatch) {
            t.ok(true, `Transaction logs for '${txLabel}' match '${msgRx.toString()}' in ${label}`);
        }
        else {
            t.fail(`Transaction logs for '${txLabel}' do not match '${msgRx.toString()}' in ${label}`);
            (0, log_1.logInfo)(`Inspect via: ${consts_1.AMMAN_EXPLORER}/#/tx/${opts.txSignature}`);
        }
    }
}
exports.assertContainMessages = assertContainMessages;
const errorFromLogsRx = /^Program.+failed: (.+)/;
const errorExcludeRx = /^Program log:/;
function maybeLogTxUrl(signature) {
    if (signature != null) {
        (0, log_1.logInfo)(`Inspect via: ${consts_1.AMMAN_EXPLORER}/#/tx/${signature}`);
    }
}
/**
 * Asserts that the provided error is defined and matches the provided
 * requirements.
 *
 * If {@link opts.type} is provided the error needs to be of that type.
 * If {@link opts.msgRx} is provided the error message needs match to it.
 *
 * @param t
 * @param err error to verify
 * @param opts
 * @param opts.type the type of the error to expect
 * @param opts.msgRx a {@link RegExp} that the error message is expected to match
 * @param opts.logMessages list of log messages parse for an error in case that {@link err} is not defined
 */
function assertErrorMatches(t, err, opts = {}) {
    var _a;
    let errMsgFromLogs = null;
    if (err == null && opts.logMessages != null) {
        for (const msg of opts.logMessages) {
            const m = msg.match(errorFromLogsRx);
            if (m != null && !errorExcludeRx.test(msg)) {
                errMsgFromLogs = m[1];
                break;
            }
        }
    }
    if (err == null && errMsgFromLogs == null) {
        t.fail(`Expected an error`);
        maybeLogTxUrl(opts.txSignature);
        return;
    }
    if (opts.type != null) {
        if (err == null && errMsgFromLogs != null) {
            t.fail(`Expected an error of type ${opts.type.name}, but did not get a typed error.` +
                ` Got: '${errMsgFromLogs}' in the logs instead`);
            maybeLogTxUrl(opts.txSignature);
        }
        else {
            if (err instanceof opts.type) {
                t.ok(true, `error is of type ${opts.type.name}`);
            }
            else {
                t.fail(`error is of type ${opts.type.name}, but is ${err}`);
                maybeLogTxUrl(opts.txSignature);
            }
        }
    }
    const msgRx = opts.msgRx;
    if (msgRx != null) {
        const msg = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : errMsgFromLogs;
        if (msg == null) {
            t.fail(`Expected error to match ${msgRx.toString()}, but did not find an error on the transaction nor in the logs`);
            maybeLogTxUrl(opts.txSignature);
        }
        else {
            if (msgRx.test(msg)) {
                t.ok(true, `error message ('${msg}') matches ${msgRx.toString()}`);
            }
            else {
                t.fail(`error message ('${msg}') does not match ${msgRx.toString()}`);
                maybeLogTxUrl(opts.txSignature);
            }
        }
    }
}
exports.assertErrorMatches = assertErrorMatches;
//# sourceMappingURL=asserts.js.map