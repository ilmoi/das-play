import { Keypair, PublicKey, Signer } from '@solana/web3.js';
import { AmmanClient } from '../relay/client';
import { KeyLike } from '../utils/keys';
/** @private */
export declare type AddLabel = (label: string, key: KeyLike) => Promise<string | undefined>;
/** @private */
export declare type AddLabels = (labels: any) => Promise<AddressLabels>;
/** @private */
export declare type GenKeypair = () => [PublicKey, Keypair];
/** @private */
export declare type GenLabeledKeypair = (label: string) => Promise<[PublicKey, Keypair, string]>;
/** @private */
export declare type StoreKeypair = (keypair: Keypair, label?: string) => Promise<string | undefined>;
/** @private */
export declare type LoadKeypair = (label: string) => Promise<[PublicKey, Keypair] | undefined>;
/** @private */
export declare type LoadOrGenKeypair = (label: string) => Promise<[PublicKey, Keypair, string]>;
/**
 * Manages address labels in order to improve logging and provide them to tools
 * like the solana explorer.
 *
 * @category diagnostics
 */
export declare class AddressLabels {
    private knownLabels;
    private readonly logLabel;
    private readonly ammanClient;
    /**
     * Creates an instance of {@link AddressLabels}.
     *
     * @param knownLabels labels keyed as [address, label] known ahead of time, i.e. program ids.
     * @param logLabel if provided to added labels are logged using this function
     */
    private constructor();
    /**
     * Clears all address labels collected so far and instructs the {@link
     * ammanClient} to do the same.
     */
    clear(): Promise<void>;
    /**
     * Adds the provided label for the provided key.
     * If the label collides with an existing label, for a different key it will
     * be suffixed with a number.
     */
    addLabel: AddLabel;
    /**
     * Adds labels for all {@link KeyLike}s it finds on the provided object
     * If the label collides with an existing label, for a different key it will
     * be suffixed with a number.
     */
    addLabels: AddLabels;
    /**
     * Adds the provided label for the provided key unless a label for that key
     * was added previously.
     */
    addLabelIfUnknown: AddLabel;
    /**
     * Resolves the {@link PublicKey}s for the given signers/keypairs.
     *
     * @return resolvedKeys which are labels for known public keys or the public key
     */
    resolveKeypairs(pairs: (Signer | Keypair)[] | Object): {
        label: string;
        key: any;
    }[];
    /**
     * Resolves a known label for the provided key or address
     * @returns label for the address or `undefined` if not found
     */
    resolve(keyOrAddress: KeyLike | string): string | undefined;
    /**
     * Resolves all addresses labeled with the {@link label}.
     * @returns addresses or empty if none found
     */
    resolveLabel(search: string): string[];
    /**
     * Resolves a known label for the provided key or address querying the amman relay if it
     * isn't found in the cache.
     * @returns label for the address or `undefined` if not found
     */
    resolveRemoteAddress(address: KeyLike): Promise<string | undefined>;
    /**
     * Resolves an address for the  provided label querying the amman relay if it
     * isn't found in the cache.
     * @returns addresses labeled with the {@link label}
     */
    resolveRemoteLabel(label: string): Promise<string[]>;
    /**
     * Resolves all labeled addresses from the amman relay and updates the local labels.
     * @returns knownLabes all known labels after the update
     */
    getRemoteLabelAddresses(): Promise<Record<string, string>>;
    /**
     * Generates a keypair and returns its public key and the keypair itself as a
     * Tuple.
     *
     * @return [publicKey, keypair ]
     * @private
     */
    genKeypair: GenKeypair;
    /**
     * Generates a keypair, labels it and returns its public key and the keypair
     * itself as a Tuple.
     *
     * @param label the key will be added to existing labels
     * @return [publicKey, keypair ]
     * @private
     */
    genLabeledKeypair: GenLabeledKeypair;
    /**
     * Loads a labeled {@link Keypair} from the relay.
     * If a {@link Keypair} with that label is not found or the relay is not connected, then it
     * returns `undefined`.
     */
    loadKeypair: LoadKeypair;
    /**
     * Loads a labeled {@link Keypair} from the relay.
     * If a {@link Keypair} with that label is not found or the relay is not connected, then it
     * returns a newly generated keypair.
     *
     */
    loadOrGenKeypair: LoadOrGenKeypair;
    /**
     * Stores the keypair in the relay using the provided label or public key as id.
     *
     * @private
     */
    storeKeypair: StoreKeypair;
    /**
     * Returns a function that allows comparing the provided key with another and
     * can be used for assertion tools like {@link spok | https://github.com/thlorenz/spok }.
     */
    isKeyOf: (key: KeyLike) => {
        (otherKey: KeyLike): boolean;
        $spec: string;
    };
    addLabelsFromText(labels: string[], text: string, opts?: {
        transactionsOnly?: boolean;
        accountsOnly?: boolean;
    }): Promise<void>;
    /**
     * Resolves the {@link PublicKey}s for the signers/keypairs it finds on the provided object.
     *
     * @return resolvedKeys which are labels for known public keys or the public key
     */
    private _findAndResolveKeypairs;
    private _nonCollidingLabel;
    private static _instance;
    static setInstance(knownLabels: Record<string, string>, logLabel?: (msg: string) => void, ammanClient?: AmmanClient): AddressLabels;
    static get instance(): AddressLabels;
}
