"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBalances = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const text_table_1 = __importDefault(require("text-table"));
const token_registry_1 = require("./token-registry");
/**
 * Interface to query token balances of a particular transaction.
 *
 * @category diagnostics
 */
class TokenBalances {
    constructor(connection, signature, addressLabels) {
        this.connection = connection;
        this.signature = signature;
        this.addressLabels = addressLabels;
    }
    /**
     * Provides an interfact to query token balances for the transaction with the
     * provided {@link signature}.
     *
     * If {@link addressLabels} are provided then they are used to resolve
     * account and mint addresses to more meaningful labels.
     */
    static forTransaction(connection, signature, addressLabels) {
        return new TokenBalances(connection, signature, addressLabels);
    }
    /**
     * Gets token balance for the provided account and mint.
     */
    async balance(account, mint) {
        const tokenBalances = await this.byAccountMap(true);
        const forAccount = tokenBalances.get(account.toBase58());
        if (forAccount == null)
            return null;
        return forAccount[mint.toBase58()];
    }
    /**
     * Gets all token balances for the transaction mapped by account and then grouped
     * by mint.
     */
    async byAccountMap(rawAddresses = false) {
        var _a, _b, _c, _d, _e, _f;
        const parsed = await this.connection.getParsedTransaction(this.signature);
        const accounts = parsed === null || parsed === void 0 ? void 0 : parsed.transaction.message.accountKeys;
        const preTokenBalances = (_a = parsed === null || parsed === void 0 ? void 0 : parsed.meta) === null || _a === void 0 ? void 0 : _a.preTokenBalances;
        const postTokenBalances = (_b = parsed === null || parsed === void 0 ? void 0 : parsed.meta) === null || _b === void 0 ? void 0 : _b.postTokenBalances;
        if ((preTokenBalances == null && postTokenBalances == null) ||
            accounts == null) {
            return new Map();
        }
        const byAccount = new Map();
        for (let { mint: rawMint, uiTokenAmount, accountIndex, } of preTokenBalances !== null && preTokenBalances !== void 0 ? preTokenBalances : []) {
            const account = this.resolveAccount(accounts, accountIndex, rawAddresses);
            if (account == null)
                continue;
            const mint = rawAddresses
                ? rawMint
                : (_d = (_c = this.addressLabels) === null || _c === void 0 ? void 0 : _c.resolve(rawMint)) !== null && _d !== void 0 ? _d : rawMint;
            byAccount.set(account, {
                [mint]: { amountPre: new bn_js_1.default(uiTokenAmount.amount), rawMint },
            });
        }
        for (let { mint: rawMint, uiTokenAmount, accountIndex, } of postTokenBalances !== null && postTokenBalances !== void 0 ? postTokenBalances : []) {
            const account = this.resolveAccount(accounts, accountIndex, rawAddresses);
            const mint = rawAddresses
                ? rawMint
                : (_f = (_e = this.addressLabels) === null || _e === void 0 ? void 0 : _e.resolve(rawMint)) !== null && _f !== void 0 ? _f : rawMint;
            if (account == null)
                continue;
            if (!byAccount.has(account)) {
                // The account has never been minted to before at all, thus has no pre balances
                byAccount.set(account, {});
            }
            const current = byAccount.get(account);
            let currentMint = current[mint];
            if (currentMint == null) {
                // The account has not been minted the mint to before and thus it has no
                // pre balance. We denote this as `0` pre balance which is what the
                // solana explorer does as well.
                currentMint = current[mint] = { amountPre: new bn_js_1.default(0), rawMint };
            }
            currentMint.amountPost = new bn_js_1.default(uiTokenAmount.amount);
        }
        return byAccount;
    }
    /**
     * Dumps all token balances to the console.
     */
    async dump(log = console.log) {
        var _a, _b;
        if (typeof (log === null || log === void 0 ? void 0 : log.enabled) !== 'undefined' && !(log === null || log === void 0 ? void 0 : log.enabled))
            return this;
        const tokenRegistry = await (0, token_registry_1.resolveTokenRegistry)();
        const balances = await this.byAccountMap();
        const rows = [
            ['Address', 'Token', 'Change', 'Post Balance'],
            ['-------', '-----', '------', '------------'],
        ];
        for (const [account, mints] of balances) {
            for (const [mintAddress, { amountPre, amountPost, rawMint },] of Object.entries(mints)) {
                const delta = new bn_js_1.default(amountPost).sub(new bn_js_1.default(amountPre));
                const unit = (_b = (_a = tokenRegistry.get(rawMint)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'tokens';
                const row = [account, mintAddress, delta, `${amountPost} ${unit}`];
                rows.push(row);
            }
        }
        log((0, text_table_1.default)(rows));
        return this;
    }
    resolveAccount(accounts, accountIndex, rawAddresses) {
        var _a, _b;
        const parsedAccount = accounts[accountIndex];
        return rawAddresses
            ? parsedAccount.pubkey.toBase58()
            : (_b = (_a = this.addressLabels) === null || _a === void 0 ? void 0 : _a.resolve(parsedAccount.pubkey)) !== null && _b !== void 0 ? _b : parsedAccount.pubkey.toBase58();
    }
}
exports.TokenBalances = TokenBalances;
//# sourceMappingURL=token-balances.js.map