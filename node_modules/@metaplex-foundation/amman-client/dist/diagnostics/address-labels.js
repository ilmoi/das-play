"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressLabels = void 0;
const web3_js_1 = require("@solana/web3.js");
const assert_1 = require("assert");
const client_1 = require("../relay/client");
const address_1 = require("../utils/address");
const keys_1 = require("../utils/keys");
const log_1 = require("../utils/log");
const address_label_mapper_1 = require("./address-label-mapper");
const { logError, logTrace } = (0, log_1.scopedLog)('addr');
/**
 * Manages address labels in order to improve logging and provide them to tools
 * like the solana explorer.
 *
 * @category diagnostics
 */
class AddressLabels {
    /**
     * Creates an instance of {@link AddressLabels}.
     *
     * @param knownLabels labels keyed as [address, label] known ahead of time, i.e. program ids.
     * @param logLabel if provided to added labels are logged using this function
     */
    constructor(knownLabels, logLabel = (_) => { }, ammanClient = client_1.ConnectedAmmanClient.getInstance()) {
        this.knownLabels = knownLabels;
        this.logLabel = logLabel;
        this.ammanClient = ammanClient;
        /**
         * Adds the provided label for the provided key.
         * If the label collides with an existing label, for a different key it will
         * be suffixed with a number.
         */
        this.addLabel = async (label, key) => {
            const keyString = (0, keys_1.publicKeyString)(key);
            if (!(0, address_1.isValidSolanaAddress)(keyString))
                return;
            label = await this._nonCollidingLabel((0, address_label_mapper_1.mapLabel)(label), keyString);
            this.logLabel(`ðŸ”‘ ${label}: ${keyString}`);
            this.knownLabels[keyString] = label;
            await this.ammanClient.addAddressLabels({ [keyString]: label });
            logTrace(`ðŸ”‘ ${label}: ${keyString}`);
            return label;
        };
        /**
         * Adds labels for all {@link KeyLike}s it finds on the provided object
         * If the label collides with an existing label, for a different key it will
         * be suffixed with a number.
         */
        this.addLabels = async (obj) => {
            if (obj != null) {
                const labels = {};
                let synced = false;
                for (let [label, key] of Object.entries(obj)) {
                    if (typeof label === 'string' && (0, keys_1.isKeyLike)(key)) {
                        const keyString = (0, keys_1.publicKeyString)(key);
                        if ((0, address_1.isValidSolanaAddress)(keyString)) {
                            label = await this._nonCollidingLabel((0, address_label_mapper_1.mapLabel)(label), keyString, !synced);
                            synced = true;
                            labels[keyString] = label;
                            this.knownLabels[keyString] = label;
                            this.logLabel(`ðŸ”‘ ${label}: ${keyString}`);
                            logTrace(`ðŸ”‘ ${label}: ${keyString}`);
                        }
                    }
                }
                await this.ammanClient.addAddressLabels(labels);
            }
            return this;
        };
        /**
         * Adds the provided label for the provided key unless a label for that key
         * was added previously.
         */
        this.addLabelIfUnknown = async (label, key) => {
            const keyString = (0, keys_1.publicKeyString)(key);
            if (this.knownLabels[keyString] == null) {
                label = await this._nonCollidingLabel((0, address_label_mapper_1.mapLabel)(label), keyString);
                await this.addLabel(label, keyString);
            }
            return label;
        };
        // -----------------
        // Keypairs
        // -----------------
        /**
         * Generates a keypair and returns its public key and the keypair itself as a
         * Tuple.
         *
         * @return [publicKey, keypair ]
         * @private
         */
        this.genKeypair = () => {
            const kp = web3_js_1.Keypair.generate();
            // NOTE: that this may fail to reach the relay before the app exists
            this.storeKeypair(kp).catch((err) => {
                logError('Ran into some issue trying to store the generated keypair');
                logError(err);
            });
            return [kp.publicKey, kp];
        };
        /**
         * Generates a keypair, labels it and returns its public key and the keypair
         * itself as a Tuple.
         *
         * @param label the key will be added to existing labels
         * @return [publicKey, keypair ]
         * @private
         */
        this.genLabeledKeypair = async (label) => {
            const tuple = this.genKeypair();
            const labelUsed = await this.addLabel(label, tuple[0]);
            const id = labelUsed !== null && labelUsed !== void 0 ? labelUsed : tuple[0].toBase58();
            await this.storeKeypair(tuple[1], id);
            return [...tuple, id];
        };
        /**
         * Loads a labeled {@link Keypair} from the relay.
         * If a {@link Keypair} with that label is not found or the relay is not connected, then it
         * returns `undefined`.
         */
        this.loadKeypair = async (label) => {
            const kp = await this.ammanClient.requestLoadKeypair(label);
            return kp != null ? [kp.publicKey, kp] : undefined;
        };
        /**
         * Loads a labeled {@link Keypair} from the relay.
         * If a {@link Keypair} with that label is not found or the relay is not connected, then it
         * returns a newly generated keypair.
         *
         */
        this.loadOrGenKeypair = async (label) => {
            const loaded = await this.ammanClient.requestLoadKeypair(label);
            return loaded != null
                ? [loaded.publicKey, loaded, label]
                : this.genLabeledKeypair(label);
        };
        /**
         * Stores the keypair in the relay using the provided label or public key as id.
         *
         * @private
         */
        this.storeKeypair = async (keypair, label) => {
            if (label != null) {
                label = await this._nonCollidingLabel(label, keypair.publicKey.toBase58());
            }
            await this.ammanClient.requestStoreKeypair(label !== null && label !== void 0 ? label : keypair.publicKey.toBase58(), keypair);
            return label;
        };
        /**
         * Returns a function that allows comparing the provided key with another and
         * can be used for assertion tools like {@link spok | https://github.com/thlorenz/spok }.
         */
        this.isKeyOf = (key) => {
            const keyString = (0, keys_1.publicKeyString)(key);
            const label = this.knownLabels[keyString];
            const fn = (otherKey) => {
                const otherKeyString = (0, keys_1.publicKeyString)(otherKey);
                return keyString === otherKeyString;
            };
            if (label != null) {
                fn.$spec = `isKeyOf('${label}')`;
            }
            return fn;
        };
        if (typeof ammanClient === 'string') {
            console.error('ADDRESS_LABLES_PATH is deprecated, you do not need to pass it anymore');
            ammanClient = client_1.ConnectedAmmanClient.getInstance();
        }
        if (Object.keys(knownLabels).length > 0) {
            this.ammanClient.addAddressLabels(knownLabels);
        }
        this.getRemoteLabelAddresses();
    }
    /**
     * Clears all address labels collected so far and instructs the {@link
     * ammanClient} to do the same.
     */
    async clear() {
        this.ammanClient.clearAddressLabels();
        this.knownLabels = {};
    }
    /**
     * Resolves the {@link PublicKey}s for the given signers/keypairs.
     *
     * @return resolvedKeys which are labels for known public keys or the public key
     */
    resolveKeypairs(pairs) {
        if (Array.isArray(pairs)) {
            return pairs.map((x) => {
                var _a;
                const keyString = x.publicKey.toBase58();
                return { label: (_a = this.knownLabels[keyString]) !== null && _a !== void 0 ? _a : '', key: keyString };
            });
        }
        else {
            return this._findAndResolveKeypairs(pairs);
        }
    }
    /**
     * Resolves a known label for the provided key or address
     * @returns label for the address or `undefined` if not found
     */
    resolve(keyOrAddress) {
        const address = (0, keys_1.publicKeyString)(keyOrAddress);
        return this.knownLabels[address];
    }
    /**
     * Resolves all addresses labeled with the {@link label}.
     * @returns addresses or empty if none found
     */
    resolveLabel(search) {
        const addresses = [];
        for (const [key, label] of Object.entries(this.knownLabels)) {
            if (label === search) {
                addresses.push(key);
            }
        }
        return addresses;
    }
    /**
     * Resolves a known label for the provided key or address querying the amman relay if it
     * isn't found in the cache.
     * @returns label for the address or `undefined` if not found
     */
    async resolveRemoteAddress(address) {
        address = (0, keys_1.publicKeyString)(address);
        const localAddress = this.knownLabels[address];
        if (localAddress != null)
            return localAddress;
        await this.getRemoteLabelAddresses();
        return this.knownLabels[address];
    }
    /**
     * Resolves an address for the  provided label querying the amman relay if it
     * isn't found in the cache.
     * @returns addresses labeled with the {@link label}
     */
    async resolveRemoteLabel(label) {
        await this.getRemoteLabelAddresses();
        return this.resolveLabel(label);
    }
    /**
     * Resolves all labeled addresses from the amman relay and updates the local labels.
     * @returns knownLabes all known labels after the update
     */
    async getRemoteLabelAddresses() {
        const remoteLabels = await this.ammanClient.fetchAddressLabels();
        this.knownLabels = { ...this.knownLabels, ...remoteLabels };
        return this.knownLabels;
    }
    async addLabelsFromText(labels, text, opts = {}) {
        const { transactionsOnly = false, accountsOnly = false } = opts;
        (0, assert_1.strict)(!transactionsOnly || !accountsOnly, 'cannot only filter by transactionsOnly or accountsOnly');
        let addresses = (0, address_1.extractSolanaAddresses)(text);
        if (transactionsOnly) {
            addresses = addresses.filter(address_1.isSignatureAddress);
        }
        else if (accountsOnly) {
            addresses = addresses.filter(address_1.isPublicKeyAddress);
        }
        if (addresses.length < labels.length) {
            if (transactionsOnly) {
                logError('Was unable to find enough transaction only addresses');
            }
            if (accountsOnly) {
                logError('Was unable to find enough account only addresses');
            }
            throw Error(`Cannot auto-label ${labels.length} labels with ${addresses.length} addresses (not enough addresses)`);
        }
        const acc = {};
        for (let i = 0; i < labels.length; i++) {
            const address = addresses[i];
            const label = labels[i];
            acc[label] = address.value;
        }
        await this.addLabels(acc);
    }
    /**
     * Resolves the {@link PublicKey}s for the signers/keypairs it finds on the provided object.
     *
     * @return resolvedKeys which are labels for known public keys or the public key
     */
    _findAndResolveKeypairs(obj) {
        const pairs = Object.entries(obj).filter(([key, val]) => typeof key === 'string' && (0, keys_1.isKeyLike)(val));
        return pairs.map(([key, val]) => {
            var _a;
            const keyString = (0, keys_1.publicKeyString)(val);
            return { label: (_a = this.knownLabels[keyString]) !== null && _a !== void 0 ? _a : key, key: keyString };
        });
    }
    async _nonCollidingLabel(label, address, syncRemote = true) {
        if (syncRemote) {
            await this.getRemoteLabelAddresses();
        }
        // We are actually trying to re-label a key that we labeled before
        if (this.knownLabels[address] != null) {
            return label;
        }
        // It's a new key, so we'll make sure that we tweak the label such that
        // two different keys won't have the same label
        const labels = new Set(Object.values(this.knownLabels));
        if (!labels.has(label))
            return label;
        let i = 0;
        do {
            i++;
            const indexedLabel = `${label}-${i}`;
            if (!labels.has(indexedLabel))
                return indexedLabel;
        } while (true);
    }
    static setInstance(knownLabels, logLabel, ammanClient) {
        if (AddressLabels._instance != null) {
            console.error('Can only set AddressLabels instance once');
            return AddressLabels._instance;
        }
        AddressLabels._instance = new AddressLabels(knownLabels, logLabel, ammanClient);
        return AddressLabels._instance;
    }
    static get instance() {
        (0, assert_1.strict)(AddressLabels._instance != null, 'need to AddressLabels.setInstance first');
        return AddressLabels._instance;
    }
}
exports.AddressLabels = AddressLabels;
//# sourceMappingURL=address-labels.js.map