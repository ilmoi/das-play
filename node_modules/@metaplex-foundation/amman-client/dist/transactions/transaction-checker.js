"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchTransactionSummary = exports.TransactionChecker = exports.TransactionCheckerAssertReturn = void 0;
const assert_1 = require("assert");
const asserts_1 = require("../asserts/asserts");
/**
 * @property summary obtained to execute the assert
 * @property processed transaction obtained to execute the assert
 **/
class TransactionCheckerAssertReturn {
    constructor(args) {
        this.txSummary = args.txSummary;
        this.txConfirmed = args.txConfirmed;
    }
    get logs() {
        return this.txSummary.logMessages;
    }
    get loggedError() {
        return this.txSummary.loggedError;
    }
    get transactionMessage() {
        return this.txConfirmed.transaction.message;
    }
}
exports.TransactionCheckerAssertReturn = TransactionCheckerAssertReturn;
/**
 * If you cannot use a builtin amman {@link TransactionHandler}, i.e. {@link PayerTransactionHandler}
 * then you can use this class to verify the outcome of your transactions.
 * @category transactions
 * @category asserts
 */
class TransactionChecker {
    constructor(connection, errorResolver) {
        this.connection = connection;
        this.errorResolver = errorResolver;
    }
    /**
     * Asserts that the transaction to completed successfully.
     *
     * @param msgRxs if provided it is verified that the logs match all these {@link RegExp}es
     * @category transactions
     * @category asserts
     */
    async assertSuccess(t, txSignature, msgRxs) {
        const { txSummary, txConfirmed } = await fetchTransactionSummary(this.connection, txSignature, this.errorResolver);
        (0, asserts_1.assertTransactionSuccess)(t, { txSummary, txSignature }, msgRxs);
        return new TransactionCheckerAssertReturn({ txSummary, txConfirmed });
    }
    /**
     * Call this if you expect the sending and confirming the transaction to
     * return with a transaction error.
     *
     * @param errOrRx either the {@link Error} type expected to be raised or same as {@link msgRx}
     * @param msgRx if provided it is verified that the error string matches this {@link RegExp}
     * @category transactions
     * @category asserts
     */
    async assertError(t, txSignature, errOrRx, msgRx) {
        const { txSummary, txConfirmed } = await fetchTransactionSummary(this.connection, txSignature, this.errorResolver);
        (0, asserts_1.assertTransactionError)(t, { txSummary, txSignature }, errOrRx, msgRx);
        return new TransactionCheckerAssertReturn({ txSummary, txConfirmed });
    }
    /**
     * Call this if to assert that the log messages match a given set of regular expressions.
     * This does not check for success or failure of the transaction.
     *
     * @param msgRxs it is verified that the logs match all these {@link RegExp}es
     * @param opts options to customize the assertion diagnostics
     * @category transactions
     * @category asserts
     */
    async assertLogs(t, txSignature, msgRxs, opts) {
        const { txSummary, txConfirmed } = await fetchTransactionSummary(this.connection, txSignature, this.errorResolver);
        (0, asserts_1.assertContainMessages)(t, txSummary.logMessages, msgRxs, opts, 'log messages');
        return new TransactionCheckerAssertReturn({ txSummary, txConfirmed });
    }
}
exports.TransactionChecker = TransactionChecker;
/** @private */
async function fetchTransactionSummary(connection, txSignature, errorResolver) {
    const txConfirmed = await connection.getTransaction(txSignature);
    (0, assert_1.strict)(txConfirmed != null, 'confirmed transaction should not be null');
    const txSummary = transactionSummary(txConfirmed, errorResolver);
    return { txSummary, txConfirmed };
}
exports.fetchTransactionSummary = fetchTransactionSummary;
function transactionSummary(tx, errorResolver) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const logMessages = (_b = (_a = tx.meta) === null || _a === void 0 ? void 0 : _a.logMessages) !== null && _b !== void 0 ? _b : [];
    const fee = (_c = tx.meta) === null || _c === void 0 ? void 0 : _c.fee;
    const slot = tx.slot;
    const blockTime = (_d = tx.blockTime) !== null && _d !== void 0 ? _d : 0;
    const transactionError = (_e = tx.meta) === null || _e === void 0 ? void 0 : _e.err;
    const errorLogs = (_h = (_g = (_f = tx.meta) === null || _f === void 0 ? void 0 : _f.err) === null || _g === void 0 ? void 0 : _g.logs) !== null && _h !== void 0 ? _h : [];
    const logs = [...errorLogs, ...logMessages];
    // TODO(thlorenz): cusper needs to get smarter and allow passing in the programs we're actually using
    // i.e. if TokenProgram is not in use it should fall thru to the SystemProgram error, i.e. for 0x0
    // it currently resolves TokenLendingProgram error which is misleading.
    // Alternatively it should include the originally parsed message as part of the error somehow so in case
    // the error is incorrectly resolved we have that information.
    const loggedError = (_j = errorResolver === null || errorResolver === void 0 ? void 0 : errorResolver.errorFromProgramLogs(logs, true)) !== null && _j !== void 0 ? _j : undefined;
    return {
        logMessages,
        fee,
        slot,
        blockTime,
        transactionError,
        loggedError,
    };
}
//# sourceMappingURL=transaction-checker.js.map