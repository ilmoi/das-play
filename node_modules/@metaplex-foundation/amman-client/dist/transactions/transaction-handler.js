"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayerTransactionHandler = void 0;
const address_labels_1 = require("../diagnostics/address-labels");
const confirmed_transaction_assertable_promise_1 = require("./confirmed-transaction-assertable-promise");
const consts_1 = require("./consts");
const transaction_checker_1 = require("./transaction-checker");
const types_1 = require("./types");
const FAIL = '❌';
function defaultTransactionLabelMapper(label) {
    return label.replace(/^(Fail|Fails|Failure|Err|Error|Bug):?/i, FAIL);
}
/**
 * A {@link TransactionHandler} backed by a payer {@link Keypair}.
 * @category transactions
 */
class PayerTransactionHandler {
    /**
     * Creates a {@link PayerTransactionHandler}.
     *
     * @param connection to use to handle transactions
     * @param payer to use to sign transactions
     * @param errorResolver used to resolve a known error from the program logs
     */
    constructor(connection, payer, errorResolver, transactionLabelMapper = defaultTransactionLabelMapper) {
        this.connection = connection;
        this.payer = payer;
        this.errorResolver = errorResolver;
        this.transactionLabelMapper = transactionLabelMapper;
    }
    /**
     * Public key of the payer
     */
    get publicKey() {
        return this.payer.publicKey;
    }
    /**
     * Sends and confirms the transaction {@link TransactionHandler['sendAndConfirmTransaction']}.
     */
    sendAndConfirmTransaction(transaction, signers, optionsOrLabel, label) {
        var _a;
        const optionsIsLabel = typeof optionsOrLabel === 'string';
        const options = optionsIsLabel ? {} : optionsOrLabel;
        const addressLabel = optionsIsLabel ? optionsOrLabel : label;
        const confirmOptions = { ...consts_1.defaultConfirmOptions, ...options };
        return new confirmed_transaction_assertable_promise_1.ConfirmedTransactionAssertablePromise(async (resolve, reject) => {
            try {
                transaction.recentBlockhash = (await this.connection.getLatestBlockhash()).blockhash;
                const txSignature = await this.connection.sendTransaction(transaction, [this.payer, ...signers], confirmOptions);
                if (addressLabel != null) {
                    address_labels_1.AddressLabels.instance.addLabel(this.transactionLabelMapper(addressLabel), txSignature);
                }
                const txRpcResponse = await this.connection.confirmTransaction(txSignature, confirmOptions.commitment);
                const { txSummary, txConfirmed } = await (0, transaction_checker_1.fetchTransactionSummary)(this.connection, txSignature, this.errorResolver);
                const details = new types_1.ConfirmedTransactionDetails({
                    txSignature,
                    txRpcResponse,
                    txConfirmed,
                    txSummary,
                });
                resolve(details);
            }
            catch (err) {
                reject(err);
            }
        }, {
            requireAssert: (_a = confirmOptions.skipPreflight) !== null && _a !== void 0 ? _a : false,
            transactionLabel: addressLabel,
        });
    }
}
exports.PayerTransactionHandler = PayerTransactionHandler;
//# sourceMappingURL=transaction-handler.js.map