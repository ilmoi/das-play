import { Assert } from '../asserts/asserts';
import { ConfirmedTransactionAsserts, ConfirmedTransactionDetails } from './types';
declare type ConfirmedTransactionAssertablePromiseOpts = {
    requireAssert: boolean;
    transactionLabel?: string;
};
/**
 * A {@link Promise} that is returned by {@link PayerTransactionHandler} `sendAndConfirmTransaction`.
 * Aside from regular promise functionality it includes `assert` methods that
 * need to be called as part of `sendAndConfirmTransaction`.
 * This way it is ensured that unexpected behavior does not go unnoticed.
 */
export declare class ConfirmedTransactionAssertablePromise extends Promise<ConfirmedTransactionDetails> implements ConfirmedTransactionAsserts {
    private calledAssert;
    private transactionLabel?;
    private errorStack?;
    constructor(executor: (resolve: (value: ConfirmedTransactionDetails | PromiseLike<ConfirmedTransactionDetails>) => void, reject: (reason?: any) => void) => void, opts?: ConfirmedTransactionAssertablePromiseOpts);
    /**
     * Call this if you expect the transaction to complete successfully.
     *
     * @param msgRxs if provided it is verified that the logs match all these {@link RegExp}es
     * @category transactions
     * @category asserts
     */
    assertSuccess(t: Assert, msgRxs?: RegExp[]): Promise<this>;
    /**
     * Call this if you expect the sending and confirming the transaction to
     * return with a transaction error.
     *
     * @param errOrRx either the {@link Error} type expected or same as {@link msgRx}
     * @param msgRx if provided it is verified that the error string matches this {@link RegExp}
     * @category transactions
     * @category asserts
     */
    assertError<Err extends Function>(t: Assert, errOrRx?: Err | RegExp, msgRx?: RegExp): Promise<this>;
    /**
     * Call this if you expect sending/confirming the transaction throws an error.
     * One example for this is failing signature verification.
     *
     * @param errOrRx either the {@link Error} type expected to be thrown or same as {@link msgRx}
     * @param msgRx if provided it is verified that the error string matches this {@link RegExp}
     * @category transactions
     * @category asserts
     */
    assertThrows<Err extends Function>(t: Assert, errOrRx?: Err | RegExp, msgRx?: RegExp): Promise<this | undefined>;
    /**
     * Call this if to assert that the log messages match a given set of regular expressions.
     * This does not check for success or failure of the transaction.
     *
     * @param msgRxs it is verified that the logs match all these {@link RegExp}es
     * @category transactions
     * @category asserts
     */
    assertLogs(t: Assert, msgRxs: RegExp[]): Promise<void>;
    /**
     * Call this to explicitly bypass any asserts but still skip preflight.
     * Use this with care as transaction errors may go unnoticed that way.
     * It is useful to capture the transaction result while diagnosing issues.
     * @category transactions
     * @category asserts
     */
    assertNone(): Promise<this>;
}
export {};
