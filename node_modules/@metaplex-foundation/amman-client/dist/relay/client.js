"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisconnectedAmmanClient = exports.ConnectedAmmanClient = void 0;
const web3_js_1 = require("@solana/web3.js");
const assert_1 = require("assert");
const socket_io_client_1 = __importDefault(require("socket.io-client"));
const browser_1 = require("../utils/browser");
const log_1 = require("../utils/log");
const consts_1 = require("./consts");
const timeout_1 = require("./timeout");
const types_1 = require("./types");
const version_1 = require("./version");
const { logError, logDebug, logTrace } = (0, log_1.scopedLog)('relay');
const RELAY_TIMEOUT_MS = 2000;
const AMMAN_NOT_RUNNING_ERROR = ', is amman running with the relay enabled?\n' +
    'If not please start it as part of amman in a separate terminal via `amman start`\n' +
    'Make sure to set `relay: { enabled: true }` in `.ammanrc.js`.\n' +
    'Alternatively set environment var `CI=1` in your current terminal or\n' +
    'instantiate amman via `const amman = Amnnan.instance({ connectClient: false })`';
/** @private */
class ConnectedAmmanClient {
    constructor(url, opts = {}) {
        this.url = url;
        this._reqId = 0;
        this._verifiedAmmanVersion = false;
        const { autoUnref = !browser_1.isBrowser, ack = false } = opts;
        this.ack = ack;
        this.socket = (0, socket_io_client_1.default)(url, { autoUnref });
    }
    connect() {
        if (this.socket.connected)
            return this;
        this.socket.connect();
        logDebug('AmmanClient connected');
        return this;
    }
    clearAddressLabels() {
        // TODO(thlorenz): this should ack to resolve a promise
        this.socket.emit(consts_1.MSG_CLEAR_ADDRESS_LABELS);
    }
    clearTransactions() {
        // TODO(thlorenz): this should ack to resolve a promise
        this.socket.emit(consts_1.MSG_CLEAR_TRANSACTIONS);
    }
    // -----------------
    // Amman Version
    // -----------------
    async fetchAmmanVersion() {
        return this._handleRequest('fetch version', consts_1.MSG_REQUEST_AMMAN_VERSION, [], consts_1.MSG_RESPOND_AMMAN_VERSION, (resolve, reject, reply) => {
            return (0, types_1.isReplyWithError)(reply)
                ? reject(reply.err)
                : resolve(reply.result);
        });
    }
    // -----------------
    // Validator Pid
    // -----------------
    async fetchValidatorPid() {
        return this._handleRequest('fetch validator pid', consts_1.MSG_REQUEST_VALIDATOR_PID, [], consts_1.MSG_RESPOND_VALIDATOR_PID, (resolve, reject, reply) => {
            return (0, types_1.isReplyWithError)(reply)
                ? reject(reply.err)
                : resolve(reply.result);
        });
    }
    // -----------------
    // Kill Amman
    // -----------------
    async requestKillAmman() {
        return this._handleRequest('fetch validator pid', consts_1.MSG_REQUEST_KILL_AMMAN, [], consts_1.MSG_RESPOND_KILL_AMMAN, (resolve, reject, { err }) => {
            if (err != null)
                return reject(new Error(err));
            resolve();
        }, 5000);
    }
    // -----------------
    // Address Labels
    // -----------------
    addAddressLabels(labels) {
        if (logTrace.enabled) {
            const labelCount = Object.keys(labels).length;
            logTrace(`Adding ${labelCount} address labels`);
        }
        const promise = this.ack
            ? new Promise((resolve, reject) => {
                const timeout = (0, timeout_1.createTimeout)(2000, new Error('Unable to add address labels' + AMMAN_NOT_RUNNING_ERROR), reject);
                this.socket
                    .on('error', (err) => {
                    clearTimeout(timeout);
                    reject(err);
                })
                    .on(consts_1.ACK_UPDATE_ADDRESS_LABELS, () => {
                    logTrace('Got ack for address labels update %O', labels);
                    clearTimeout(timeout);
                    resolve();
                });
            })
            : Promise.resolve();
        const reply = {
            result: { labels },
        };
        this.socket.emit(consts_1.MSG_UPDATE_ADDRESS_LABELS, reply);
        return promise;
    }
    async fetchAddressLabels() {
        return this._handleRequest('fetch address labels', consts_1.MSG_GET_KNOWN_ADDRESS_LABELS, [], consts_1.MSG_UPDATE_ADDRESS_LABELS, (resolve, reject, reply) => {
            if ((0, types_1.isReplyWithError)(reply))
                return reject(reply.err);
            const labels = reply.result.labels;
            logTrace('Got address labels %O', labels);
            resolve(labels);
        });
    }
    async fetchAccountStates(address) {
        return this._handleRequest(`fetch account states for ${address}`, consts_1.MSG_REQUEST_ACCOUNT_STATES, [address], consts_1.MSG_RESPOND_ACCOUNT_STATES, (resolve, reject, reply) => {
            if ((0, types_1.isReplyWithError)(reply))
                return reject(reply.err);
            const { pubkey, states } = reply.result;
            logDebug('Got account states for address %s, %O', pubkey, states);
            resolve(states);
        });
    }
    async requestSnapshot(label) {
        label !== null && label !== void 0 ? label : (label = new Date().toJSON().replace(/[:.]/g, '_'));
        return this._handleRequest('request snapshot accounts', consts_1.MSG_REQUEST_SNAPSHOT_SAVE, [label], consts_1.MSG_RESPOND_SNAPSHOT_SAVE, (resolve, reject, reply) => {
            if ((0, types_1.isReplyWithError)(reply))
                return reject(new Error(reply.err));
            const snapshotDir = reply.result;
            (0, assert_1.strict)(snapshotDir != null, 'expected either error or snapshotDir');
            logDebug('Completed snapshot at %s', snapshotDir);
            resolve(snapshotDir);
        });
    }
    async requestLoadSnapshot(label) {
        return this._handleRequest('request load snapshot', consts_1.MSG_REQUEST_LOAD_SNAPSHOT, [label], consts_1.MSG_RESPOND_LOAD_SNAPSHOT, (resolve, reject, reply) => {
            return (0, types_1.isReplyWithError)(reply) ? reject(reply.err) : resolve();
        }, 5000);
    }
    async requestSaveAccount(address) {
        return this._handleRequest(`save account ${address}`, consts_1.MSG_REQUEST_ACCOUNT_SAVE, [address], consts_1.MSG_RESPOND_ACCOUNT_SAVE, (resolve, reject, reply) => {
            if ((0, types_1.isReplyWithError)(reply))
                return reject(new Error(reply.err));
            const { accountPath } = reply.result;
            (0, assert_1.strict)(accountPath != null, 'expected either error or accountPath');
            logDebug('Completed saving account at %s', accountPath);
            resolve(accountPath);
        });
    }
    async requestStoreKeypair(id, keypair) {
        const key = keypair.publicKey.toBase58();
        const taskSuffix = id === key ? `"${id}"` : `"${id}" (${key})`;
        return this._handleRequest(`store keypair ${taskSuffix}`, consts_1.MSG_REQUEST_STORE_KEYPAIR, [id, keypair.secretKey], consts_1.MSG_RESPOND_STORE_KEYPAIR, (resolve, reject, reply) => {
            return (0, types_1.isReplyWithError)(reply) ? reject(reply.err) : resolve();
        });
    }
    async requestLoadKeypair(id) {
        return this._handleRequest(`load keypair ${id}`, consts_1.MSG_REQUEST_LOAD_KEYPAIR, [id], consts_1.MSG_RESPOND_LOAD_KEYPAIR, (resolve, reject, reply) => {
            if ((0, types_1.isReplyWithError)(reply))
                return reject(new Error(reply.err));
            try {
                const { keypair } = reply.result;
                resolve(keypair != null ? web3_js_1.Keypair.fromSecretKey(keypair) : undefined);
            }
            catch (err) {
                logError('Failed to load keypair with id "%s"', id);
                logError(err);
                resolve(undefined);
            }
        });
    }
    requestSetAccount(persistedAccountInfo) {
        return this._handleRequest('set account', consts_1.MSG_REQUEST_SET_ACCOUNT, [persistedAccountInfo], consts_1.MSG_RESPOND_SET_ACCOUNT, (resolve, reject, reply) => {
            return (0, types_1.isReplyWithError)(reply) ? reject(reply.err) : resolve();
        }, 5000);
    }
    requestRestartValidator() {
        return this._handleRequest('', consts_1.MSG_REQUEST_RESTART_VALIDATOR, [], consts_1.MSG_RESPOND_RESTART_VALIDATOR, (resolve, reject, reply) => {
            return (0, types_1.isReplyWithError)(reply) ? reject(reply.err) : resolve();
        }, 5000);
    }
    _handleRequest(action, request, requestArgs, response, responseHandler, timeoutMs = RELAY_TIMEOUT_MS) {
        return new Promise(async (resolve, reject) => {
            try {
                await this._verifyAmmanVersion();
            }
            catch (err) {
                return reject(err);
            }
            const reqId = this._reqId++;
            const onResponse = (...args) => {
                logTrace('<- [%s][%d]', action, reqId);
                clearTimeout(timeout);
                responseHandler(resolve, reject, ...args);
                this.socket.off(response, onResponse);
            };
            const timeout = (0, timeout_1.createTimeout)(timeoutMs, new Error(`Unable to ${action}. ${AMMAN_NOT_RUNNING_ERROR}`), (reason) => {
                logError(`'${request}' timed out`);
                reject(reason);
            });
            this.socket
                .on('error', (err) => {
                clearTimeout(timeout);
                reject(err);
            })
                .on(response, onResponse)
                .emit(request, ...requestArgs);
            logTrace('-> [%s][%d]', action, reqId);
        });
    }
    async _verifyAmmanVersion() {
        if (this._verifiedAmmanVersion)
            return Promise.resolve();
        // Setting this early to avoid endless loop due to using _handleRequest below
        this._verifiedAmmanVersion = true;
        return this._handleRequest('fetch version', consts_1.MSG_REQUEST_AMMAN_VERSION, [], consts_1.MSG_RESPOND_AMMAN_VERSION, (resolve, reject, reply) => {
            if (Array.isArray(reply)) {
                const msg = `It appears you're using an outdated amman cli version ${(0, version_1.versionString)(reply)}\n` + version_1.ENSURE_VERSION;
                reject(new Error(msg));
            }
            else if ((0, types_1.isReplyWithError)(reply)) {
                const msg = `Encountered error when trying to verify amman compatibility:\n${reply.err.toString()}\n` +
                    version_1.ENSURE_VERSION;
                reject(new Error(`${reply.err}\n${msg})`));
            }
            else if (!(0, version_1.requiredVersionSatisfied)(reply.result)) {
                const msg = `It appears you're using an outdated amman cli version ${(0, version_1.versionString)(reply.result)}\n` + version_1.ENSURE_VERSION;
                reject(new Error(msg));
            }
            else {
                logDebug(`Verified that ${(0, version_1.versionString)(reply.result)} >= ${(0, version_1.versionString)(version_1.MIN_AMMAN_CLI_VERSION_REQUIRED)}.`);
                resolve();
            }
        });
    }
    /**
     * Disconnects this client and allows the app to shut down.
     * Only needed if you set `{ autoUnref: false }` for the opts.
     */
    disconnect() {
        this.socket.disconnect();
    }
    /**
     * Disconnects this client preventing reconnects and allows the app to shut
     * down. Only needed if you set `{ autoUnref: false }` for the opts.
     */
    destroy() {
        // @ts-ignore it' private
        if (typeof this.socket.destroy === 'function') {
            // @ts-ignore it' private
            this.socket.destroy();
        }
    }
    static getInstance(url, ammanClientOpts) {
        if (ConnectedAmmanClient._instance != null)
            return ConnectedAmmanClient._instance;
        ConnectedAmmanClient._instance = new ConnectedAmmanClient(url !== null && url !== void 0 ? url : consts_1.AMMAN_RELAY_URI, ammanClientOpts).connect();
        return ConnectedAmmanClient._instance;
    }
}
exports.ConnectedAmmanClient = ConnectedAmmanClient;
/** @private */
class DisconnectedAmmanClient {
    clearAddressLabels() { }
    clearTransactions() { }
    addAddressLabels(_labels) {
        return Promise.resolve();
    }
    fetchAddressLabels() {
        return Promise.resolve({});
    }
    fetchAccountStates(_address) {
        return Promise.resolve([]);
    }
    requestSnapshot(_label) {
        return Promise.resolve('');
    }
    requestLoadSnapshot(_label) {
        return Promise.resolve();
    }
    requestSaveAccount(_address) {
        return Promise.resolve('');
    }
    requestStoreKeypair(_label, _keypair) {
        return Promise.resolve();
    }
    requestLoadKeypair(_id) {
        return Promise.resolve(undefined);
    }
    requestSetAccount(_persistedAccountInfo) {
        return Promise.resolve();
    }
    requestRestartValidator() {
        return Promise.resolve();
    }
    requestKillAmman() {
        return Promise.resolve();
    }
    disconnect() { }
    destroy() { }
}
exports.DisconnectedAmmanClient = DisconnectedAmmanClient;
//# sourceMappingURL=client.js.map